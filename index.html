<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Lambdas: Myths and Mistakes</title>

		<meta name="description" content="">
		<meta name="author" content="Richard Warburton">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
		
        <link rel="stylesheet" href="extra.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
        <!-- possibly make slides bigger -->
			<div class="slides">

				<section>
					<h1>Lambdas: Myths and Mistakes</h1>
					<h3>by Richard Warburton</h3>

					<aside class="notes">
					</aside>
				</section>

				<section>
                    <blockquote>
                        Learning FP is so much more than just knowing what map/fold/filter/etc. do. 
                        It's more like getting good at Portal :)
                    </blockquote>
                    <p>@copumpkin</p>

					<aside class="notes">
                        Before we go into details ...
                        <br /> Explain quote
                        <br /> What does he really mean: idioms and technique are what is important.
					</aside>

				</section>
				
                <section>
                    <h2>Who am I?</h2>
                    <ul>
                        <li class="fragment roll-in">Currently work at jClarity</li>
                        <li class="fragment roll-in">PhD</li>
                        <li class="fragment roll-in">Adopt a JSR (Date and Time + Lambdas)</li>
                        <li class="fragment roll-in">Writing a book for O'Reilly Media on Lambda Expressions in Java 8.</li>
                    </ul>

                    <aside class="notes">
                        Taught Functional during PhD
                        <br />
					</aside>
				</section>

                <section>
                    <h1>Talk Structure</h1>
                    <ul>
                        <li>Background and Motivation</li>
                        <li>Introduction to Lambda Expressions</li>
                        <li>Beyond the Myths</li>
                        <li>Functional Thinking</li>
                    </ul>
                    <aside class="notes">
                        intro-ing in case there are people in the audience who don't know lambda expressions.
					</aside>
				</section>

                <section data-transition="linear" data-background="#007777" data-background-transition="slide">
                    <h1>Background and Motvation</h1>
                    <aside class="notes">
                        Why am I talking about this?
                        <br /> How did I get here?
                    </aside>
                </section>

                <section>
                    <h2>Lambda Expressions are coming in Java 8!</h2>
                    <aside class="notes">
                        Also massively improved collections library
                        <br /> Biggest change since generics
                        <br /> Language changes relatively small, library changes are the important thing
                        <br /> Language change enables library change
                    </aside>
                </section>

                <section>
                    <h2>Lots of discussion/debate</h2>
                    <aside class="notes">
                        Everyone has an opinion
                        <br /> That's healthy
                        <br /> Amount of irrelevant debate that goes on unhealthy, people shouting opinions
                        <br /> problems are hard, need to balance specialist implementor knowledge with mass-market usecases
                        <br /> lambda-dev was ineffective tool for discussion
                    </aside>
                </section>

                <section>
                    <h2>How can we help?</h2>
                    <p>Adopt-a-JSR</p>
                    <aside class="notes">
                        Community involvement and community driven standards.
                    </aside>
                </section>

                <section>
                    <h2>Adopt-a-JSR?</h2>
                    <ul>
                        <li>Community driven standards feedback</li>
                        <li class="fragment highlight-blue">Hackdays</li>
                        <li>Serve on Expert Groups</li>
                        <li>Initiated by Martijn Verburg</li>
                    </ul>
                    <aside class="notes">
                        Community involvement and community driven standards
                        <br /> Opinions of one person not so relevant
                        <br /> entire community is important - tough because people differ
                        <br /> report feedback to EG
                        <br /> trialled by James Gough and I on JSR-310.
                    </aside>
                </section>

                <section>
                    <h2>Some discussion unimportant</h2>
                    <p>Concrete Examples focus discussion</p>
                    <aside class="notes">
                        A lot of the mistakes people made were similar
                        <br /> similar to the mistakes I made, know several java champs similar mistake
                        <br /> Conclusion: other people not at hackdays
                        <br /> "We're not different you and I"
                    </aside>
                </section>

                <section data-transition="linear" data-background="#4d7e65" data-background-transition="slide">
                    <h1>Introduction to Lambda Expressions</h1>
                    <aside class="notes">
                    </aside>
                </section>

<!-- slides 30 - 58 -->

                <section>
                    <h2>Overview of Lambdas</h2>
                    <ul>
                        <li>Goal: Better Libraries</li>
                        <li>Example: Data Parallelism</li>
                        <li>Approach: Allow Code as Data</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Action Listener</h2>
                    <pre><code>
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        System.out.println("button clicked");
    }
});
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Code as Data</h2>
                    <pre><code>
button.addActionListener(
    ?
);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Need a parameter</h2>
                    <pre><code>
button.addActionListener(event ->

);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Lambda Example</h2>
                    <pre><code>
button.addActionListener(event ->
    System.out.println("button clicked")
);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>No parameters</h2>
                    <pre><code>
Runnable helloWorld =
    () -> System.out.println("Hello World");
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Variable Capture</h2>
                    <pre><code>
String name = getUserName();
button.addActionListener(event ->
    System.out.println("hi " + name)
);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Functional Interfaces</h2>
                    <ul>
                        <li>Everything in Java has a type</li>
                        <li>Problem: Need types to represent Functions</li>
                        <li>Solution: Use interfaces</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Functional Interfaces</h2>
                    <pre><code>
public interface ActionListener extends EventListener {
    public void actionPerformed(ActionEvent event);
}
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Functional Interfaces</h2>
                    <ul>
                        <li>Want to support automated Data Parallelism</li>
                        <li>Construct for building computation pipelines</li>
                        <li>Like an Iterator but with inversion of control</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>External Iteration</h2>
                    <pre><code>
int count = 0;
for (Artist artist : artists) {
    if (artist.isFrom("London")) {
        count++;
    }
}
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>External Iteration</h2>
                    <pre><code>
artists.stream()
       .filter(artist -> artist.isFrom("London"));
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>map</h2>
                    <img src="imgs/map.png" />
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>map</h2>
                    <pre><code>
List<String> collected =
  Stream.of("a", "b", "hello")
        .map(string -> string.toUpperCase())
        .collect(toList());

assertEquals(
asList("A", "B", "HELLO"),
collected);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>reduce</h2>
                    <img src="imgs/reduce.png" />
                    <aside class="notes">
                    </aside>
                </section>
                
                <section>
                    <h2>reduce</h2>
                    <pre><code>
int count =
    Stream.of(1, 2, 3)
          .reduce(0, (acc, x) -> acc + 1);

assertEquals(3, count);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>filter</h2>
                    <img src="imgs/filter.png" />
                    <aside class="notes">
                    </aside>
                </section>
                
                <section>
                    <h2>filter</h2>
                    <pre><code>
List<String> beginningWithNumbers =   
    Stream.of("a", "1abc", "abc1")
          .filter(value -> isDigit(value.charAt(0)))
          .collect(toList());

assertEquals(
asList("1abc"),
beginningWithNumbers);
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together</h2>
                    <p>for a given an album, find the nationality of every band playing on that album</p>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together (2)</h2>
                    <ol>
                        <li>get all the artists for an album</li>
                        <li>figure out which artists are bands</li>
                        <li>find the nationalities of each band</li>
                        <li>put together a list of these values</li>
                    </ol>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together (3)</h2>
                    <pre><code>
List<String> origins =
  album.getMusicians()
       .filter(artist -> artist.getName().startsWith("The"))
       .map(artist -> artist.getNationality())
       .collect(toList());
                    </code></pre>
                    <aside class="notes">
                    </aside>
                </section>

                <section data-transition="linear" data-background="#8c4738" data-background-transition="slide">
                    <h1>Beyond the Myths</h1>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Claim: Syntax is the most important thing about Lambda Expressions</h2>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <blockquote>
                        Yeah, I liked the # syntax proposal better, too.  One less character
                        to type!  :)
                    </blockquote>
                    <aside class="notes">
                        Referring to a preference over ::
                    </aside>
				</section>

                <section>
                    <blockquote>
                        Have you considered 'default null'?  It will save a keyword
                    </blockquote>
                    <aside class="notes">
                        asking for things being too short at the expense of readability.
                    </aside>
				</section>

                <section>
                    <blockquote>
                        How about a single punctuation mark, currently unused, as syntax sugar
                        for "()->".
                    </blockquote>
                    <aside class="notes">
                        Extreme operator usage.
                    </aside>
				</section>

                <section>
                    <blockquote>
                        (_, _) -> _ + _
                    </blockquote>

                    <br />

                    <blockquote>
                        This is starting to look like risque ASCII art :)
                    </blockquote>
                    <aside class="notes">
                        Joke Slide: absurdism
                    </aside>
				</section>

                <section>
                    <h2>Its a Myth!</h2>
                    <img src="imgs/nessie.jpg" />
                    <aside class="notes">
                        People asked about the syntax but very little explanation and only a few examples were required.
                        <br /> Vast amounts more thought going into type inference, type system changes and overload resolution.
                    </aside>
                </section>

                <section>
                    <h2>Claim: Syntax is irrelevant</h2>
                    <img class="fragment" src="imgs/nessie-2.jpg" />
                    <aside class="notes">
                        Whilst token substitution not important, people did get tripped up on syntax.
                    </aside>
                </section>

                <section>
                    <pre><code data-trim>
// Originally invalid
Stream.of(1, 2, 3)
      .forEach(x -> System.out.println(x));

// Required extra ;
Stream.of(1, 2, 3)
      .forEach(x -> System.out.println(x););
                    </code></pre>
                    <aside class="notes">
                        Tripped up loads of people
                        <br />Incredibly confusing compiler message
                        <br />Issue was that println returned void and was a statement
                        <br />Need a ; at the end of statements
                        <br />thankfully fixed after being reported
                    </aside>
                </section>

                <section>
                    <h2>Difference between expectations</h2>
                    <ul>
                        <li>Many language features <strike>stolen!</strike> adapted</li>
                        <li>Missing Features
                        <ul>
                            <li>Stronger Type System</li>
                            <li>Tuples</li>
                            <li>List construction syntax</li>
                        </ul>
                    </ul>
                    <aside class="notes">
                        stolen vs adapted: frame of reference.  Reality is there's a lot of work to bring changes into Java 8.
                        <br /> Point is no Java dev I spoke to ever complained about the lack of higher kinded types.
                        <br /> experienced fpers from other areas wanted features they were used to.
                        <br /> Not a good or bad feature change, just a different perspective.
                    </aside>
                </section>

                <section>
                    <h2>Framing Effect</h2>
                    <p>Different reactions depending on whether something is presented as a loss or a gain.</p>
                    <aside class="notes">
                        Basic Psychology
                        <br /> "Prospect theory shows that a loss is more significant than the equivalent gain"
                        <br /> Coming from Scala: you might expect tuples and higher kinded types
                        <br /> Coming from Java 7 you're happy with what's provided
                        <br /> Also results in the general reaction from Scala devs that they aren't coming back
                    </aside>
                </section>
                
                <section>
                    <h2>Very little TDD</h2>
                    <ul>
                        <li>Only a couple of developers used TDD or unit tests</li>
                        <li>Maybe a reflection on general TDD</li>
                        <li>Maybe unfamiliarity with testing functional code</li>
                    </ul>
                    <aside class="notes">
                        might be part of a hackday environment: experimentation not reliable code
                        <br /> some people tried to do TDD
                        <br /> theoretically functional code easier to test
                        <br /> specification based testing
                    </aside>
                </section>

                <section>
                    <h2>How do I test this?</h2>
                    <pre><code>
list.stream()
    .map(x -> 1.0 / Math.ceil(1 + Math.pow(x) + Math.atan2(0, x)))
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        Issue is that lambda expressions aren't reference-able.
                        <br /> Say your lambda expression interacts with a database: how do you mock it?
                        <br /> Anyone spot the subtle bug?
                        <br /> atan2(0,0) is mathematically undefined, Java gives an answer
                    </aside>
                </section>

                <section>
                    <h2>Approach 1: Test whole function</h2>
                    <ul>
                        <li>Don't test the lambda</li>
                        <li>Test the method its surrounded by</li>
                        <li>Works well for simple lambdas</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Approach 2: Extract Method</h2>
                    <pre><code>
double complexFunction(double x) {
    return 1.0 / Math.ceil(1 + Math.pow(x) + Math.atan2(0, x));
}

list.stream()
    .map(this::complexFunction)
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        extract your lambda out to a function if its complex.
                        <br /> Still get the code reuse and stream functionality through method references
                        <br /> Method references really help testability for things like this.
                    </aside>
                </section>

                <section>
                    <h2>Mistake: debugging</h2>
                    <pre><code>
list.stream()
    .filter(filteringFunction)
    .map(mappingFunction)
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        Issue is understanding intermediate values.
                    </aside>
                </section>

                <section>
                    <h2>peek</h2>
                    <pre><code>
list.stream()
    .filter(filteringFunction)
    .peek(e -> System.out.println("Filtered value: " + e));
    .map(mappingFunction)
    .map(e -> e);
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        could also be logging output or debugger breakpoint.
                        <br /> similar to the unix tee program.  Hands up.
                    </aside>
                </section>

                <!-- MAYBE: -->
                <!-- mention flatmap redesign? -->
                <!-- Pulling into local variables vs chaining -->

                <!--
TODO:
overload resolution + compiler errors
consider example of comparator
-->

                <section>
                    <h2>Compiler Error Messages</h2>
                    <aside class="notes">
                        Very important
                        <br /> influential in the learning process.
                        <br /> Are they idiomatic? Are they easy to understand?
                    </aside>
                </section>

                <section>
                    <h2>Comparators</h2>
                    <pre><code>
Comparator<String> comparator = comparing(String::length);

Comparator<String> comparator = comparing(str -> str.length);
                    </code></pre>
                    <aside class="notes">
                        Comparator is a functional interface.
                        <br /> provides some static methods for comparing by keys
                        <br /> explanatory example
                    </aside>
                </section>

                <section>
                    <h2>Compiler Error</h2>
                    <pre><code>
java: reference to comparing is ambiguous both
    method <T>comparing(java.util.function.ToIntFunction<? super T>) in java.util.Comparator and
    method <T,U>comparing(java.util.function.Function<? super T,? extends U>) in java.util.Comparator match
                    </code></pre>
                    <aside class="notes">
                        Overload resolution failure.
                        <br /> current state of play, but not likely to have a language fix
                        <br /> may change libraries
                    </aside>
                </section>

                <section>
                    <h2>What happened?</h2>
                    <pre><code>
// Generic object variant
public static <T, U extends Comparable<? super U>>
    Comparator<T>
        comparing(Function<? super T, ? extends U> keyExtractor)

// Specialised primitive variant
public static <T>
    Comparator<T>
        comparing(ToIntFunction<? super T> keyExtractor)
                    </code></pre>
                    <aside class="notes">
                        overloads are an issue
                        <br /> explain primitive specialised variant
                        <br /> overloads + type inference can be a bad combo, quite unusual
                        <br /> recommendation to library writers: don't overload on functional interfaces
                    </aside>
                </section>

                <section>
                    <h2>Summary</h2>
                    <ul>
                        <li>Syntax important, but not in the way people think</li>
                        <li>New approaches for debugging and testing</li>
                        <li>Take care of overloads and compiler error messages</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section data-transition="linear" data-background="#4d7e65" data-background-transition="slide">
                    <h1>Functional Thinking</h1>
                    <aside class="notes">
                        Say what I mean
                        <br /> look at a couple of examples
                        <br /> try and think of solutions
                    </aside>
                </section>

                <section>
                    <h1>Functional Thinking?</h1>
                    <p>Thinking in terms of the input to output relationship and not a sequence of steps</p>
                    <aside class="notes">
                        What is it?
                        <br /> Functional means different things to different communities
                        <br /> clojure: immutability, haskell: purity + monads, scala: a series of nouns which can be used for trolling.
                        <br /> Biggest issue that I saw: easy to develop and understand, but takes a bit of practise.
                        <br /> In the same way that patterns such as SOLID exist in OOP and take a while to develop.
                    </aside>
                </section>

                <section>
                    <h2>First code that people write</h2>
                    <pre><code>
List<Integer> numbers = Arrays.asList(1, 2, 3);
numbers.forEach(x -> {
    System.out.println(x);
});
                    </pre></code>
                    <aside class="notes">
                        Pretty consistent in understanding internal vs external iteration.
                        <br /> not initially trying higher order functions.
                    </aside>
                </section>

                <section>
                    <h2>Non-idiomatic Proposals</h2>
                    <p>Eg: capture non-final local variables</p>
                    <aside class="notes">
                        A lot of people want features which aren’t in the direction of java 8
                        <br /> doesn't make parallelism easier.
                    </aside>
                </section>

                <section>
                    <h2>Example Problem</h2>
                    <p>Count the number of instances of each word in a document.</p>
                    <aside class="notes">
                        Required understanding of the collectors abstraction.
                        <br /> Given a stream of words as input.
                    </aside>
                </section>

                <section>
                    <h2>Example Problem</h2>
                    <img src="imgs/stephen-colebourne.jpg" />
                    <aside class="notes">
                        <br /> emphasize he’s a really good programmer, conference speaker, jodatime author
                        <br /> mention annecdote with stuart marks' laptop
                    </aside>
                </section>

                <section>
                    <h2>Ideal Solution</h2>
                    <pre><code>
reader.lines()
      .flatMap(s -> Stream.of(s.split(" ")))
      .collect(groupingBy(s -> s, counting()));
                    </pre></code>
                    <aside class="notes">
                        Explain code
                        <br /> explain the breakdown
                        <br /> emphasize the downstream collectors
                    </aside>
                </section>

                <section>
                    <h2>Ideal Solution (then)</h2>
                    <pre><code>
reader.lines()
      .flatMap(s -> Stream.of(s.split(" ")))
      .collect(groupingBy(s -> s, reducing(s -> 1, Integer::sum)));

// Map entries for "dad"
// [ "dad", "dad", "dad" ] => [1, 1, 1] => 3
                    </pre></code>
                    <aside class="notes">
                        Counting not originally there.
                        <br /> Subsequently added.
                        <br /> People not only failed to get there, but also failed to understand the solution when presented
                    </aside>
                </section>

                <section>
                    <h2>Bad Solution (Part 1)</h2>
                    <pre><code>
Map<String, List<String>> initial
      = br.lines()
          .flatMap(s -> Arrays.stream(s.split(" ")))
          .collect(groupingBy(s -> s));
  
  Map<Map.Entry<String, Integer>, Integer> freq1 = initial
    .entrySet().stream()
    .map(entry -> new AbstractMap.SimpleImmutableEntry<String,
Integer>(entry.getKey(), entry.getValue().size()))
    .collect(Collectors.toMap(entry -> entry.getValue()));
                    </pre></code>
                    <aside class="notes">
                        nearly right to begin with
                        <br />building the map up
                        <br />doesn't realise about downstream collectors
                    </aside>
                </section>

                <section>
                    <h2>Bad Solution (Part 2)</h2>
                    <pre><code>
  Supplier<HashMap<String, Integer>> supplier = () -> new
HashMap<String, Integer>();
  BiConsumer<HashMap<String, Integer>, Map.Entry<String, Integer>> accum =
    (HashMap<String, Integer> result, Map.Entry<String, Integer>
entry) -> result.put(entry.getKey(), entry.getValue());
  BiConsumer<HashMap<String, Integer>, HashMap<String, Integer>>
merger = HashMap::putAll;

  Map<String, Integer> freq2 = initial.entrySet().stream()
    .map(entry -> new AbstractMap.SimpleImmutableEntry<String,
Integer>(entry.getKey(), entry.getValue().size()))
    .collect(supplier, accum, merger);
                    </pre></code>
                    <aside class="notes">
                        downhill from there, don't worry about understanding this code
                        <br /> make point of weird approach if things start looking like this
                        <br /> also, choose first steps wisely
                        <br /> sometimes indicates a lack of library knowledge
                        <br /> you'll write something like this, treat it as a learning experience not "FP is unreadable."
                    </aside>
                </section>

<!--
                <section>
                    <h2></h2>
                    <p></p>
                    <aside class="notes">
                    </aside>
                </section>

Maybe mention Continued Language weaknesses
immutable objects - findbugs/mutability detector
-->
                <section>
                    <h2>Summary</h2>
                    <ul>
                        <li>Functional Thinking the most important thing to learn</li>
                        <li>Not Java specific at all</li>
                        <li>Requires Practise</li>
                    </ul>
                    <aside class="notes">
                        Recognising the problem is the first step
                    </aside>
                </section>

                <section>
                    <h1>Conclusions</h1>
                    <ul>
                        <li>Gone through a bunch of examples of specific issues</li>
                        <li>‘Functional Thinking’: Not necessary to start learning.</li>
                        <li>Try before you buy</li>
                    </ul>

                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h1>Questions?</h1>
                    <p>@RichardWarburto<p>
                    <p><a href="http://insightfullogic.com">http://insightfullogic.com</a></p>
                    <p><a href="https://github.com/RichardWarburton/">https://github.com/RichardWarburton/</a></p>
                </section>

            </div>
        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.min.js"></script>

        <script>
            // Full list of configuration options available here:
            // https://github.com/hakimelreveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });
        </script>

</body>
</html>

