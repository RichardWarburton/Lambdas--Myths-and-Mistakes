<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Lambdas: Myths and Mistakes</title>

		<meta name="description" content="">
		<meta name="author" content="Richard Warburton">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="reveal.js/css/theme/night.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">
		
        <link rel="stylesheet" href="extra.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
		<div class="reveal">
        <!-- possibly make slides bigger -->
			<div class="slides">

				<section>
					<h1>Lambdas: Myths and Mistakes</h1>
					<h3>by Richard Warburton</h3>

					<aside class="notes">
					</aside>
				</section>
                
<!--
                        Learning FP is so much more than just knowing what map/fold/filter/etc. do. 
                        It's more like getting good at Portal :)
                        -->

				<section>
                    <blockquote>
                        the critical design tool for software development is a mind well educated in design principles.
                        It is not ... technology.
                    </blockquote>
                    <p>Craig Larman</p>

					<aside class="notes">
                        Before we go into details ...
                        <br /> Explain quote
                        <br /> What does he really mean: idioms and technique are what is important.
					</aside>

				</section>
		<!--	
                <section>
                    <h2>Who am I?</h2>
                    <ul>
                        <li>Focus on Performance Tuning</li>
                        <li>Adopt a JSR (Date and Time + Lambdas)</li>
                        <li>Impending O'Reilly book on Lambda Expressions in Java 8.</li>
                    </ul>

                    <aside class="notes">
                        Taught Functional during PhD
                        <br />
					</aside>
				</section>
		-->	
                
                <section>
                    <h1>Talk Structure</h1>
                    <ul>
                        <li>Why am I talking about this?</li>
                        <li>Intro to Lambda Expressions</li>
                        <li>Beyond the Myths</li>
                        <li>Functional Thinking</li>
                    </ul>
                    <aside class="notes">
                        intro-ing in case there are people in the audience who don't know lambda expressions.
					</aside>
				</section>

                <section data-transition="linear" data-background="#007777" data-background-transition="slide">
                    <h1>Why am I talking about this?</h1>
                    <aside class="notes">
                        <br /> How did I get here?
                    </aside>
                </section>

                <section>
                    <h2>Lambda Expressions are coming in Java 8!</h2>
                    <aside class="notes">
                        Also massively improved collections library
                        <br /> Biggest change since generics
                        <br /> Language changes relatively small, library changes are the important thing
                        <br /> Language change enables library change
                    </aside>
                </section>

                <section>
                    <h2>lots of discussion/debate</h2>
                    <aside class="notes">
                        Everyone has an opinion
                        <br /> That's healthy
                        <br /> Amount of irrelevant debate that goes on unhealthy, people shouting opinions
                        <br /> problems are hard, need to balance specialist implementor knowledge with mass-market usecases
                        <br /> lambda-dev was ineffective tool for discussion
                    </aside>
                </section>

                <section>
                    <h2>How can we help?</h2>
                    <p>Adopt-a-JSR</p>
                    <aside class="notes">
                        Community involvement and community driven standards.
                    </aside>
                    <aside class="notes">
                        Poll if people have heard of it?
                    </aside>
                </section>

                <section>
                    <h2>Adopt-a-JSR?</h2>
                    <ul>
                        <li>More community driven standards</li>
                        <li class="fragment highlight-blue">Hackdays</li>
                        <li>Serve on Expert Groups</li>
                    </ul>
                    <aside class="notes">
                        Community involvement and community driven standards
                        <br /> Opinions of one person not so relevant
                        <br /> entire community is important - tough because people differ
                        <br /> report feedback to EG
                        <br /> trialled by James Gough and I on JSR-310.
                    </aside>
                </section>

                <section>
                    <h2>Some discussion unimportant</h2>
                    <p>Concrete Examples focus discussion</p>
                    <aside class="notes">
                        A lot of the mistakes people made were similar
                        <br /> similar to the mistakes I made, know several java champs similar mistake
                        <br /> Conclusion: other people not at hackdays
                        <br /> "We're not so different you and I"
                    </aside>
                </section>

                <section data-transition="linear" data-background="#4d7e65" data-background-transition="slide">
                    <h1>Intro to Lambda Expressions</h1>
                    <aside class="notes">
                        Poll people about to ask about whether they have tried out binaries and
                        been following changes
                    </aside>
                </section>

                <section>
                    <h2>Overview of Lambdas</h2>
                    <ul>
                        <li>Goal: Better Libraries</li>
                        <li>Example: Collections with Data Parallelism</li>
                        <li>Approach: Allow Code as Data</li>
                    </ul>
                    <aside class="notes">
                        Specific example
                        <br /> threading model very tied in
                        <br /> hard to abstract the what from the how
                    </aside>
                </section>

                <section>
                    <h2>Action Listener</h2>
                    <pre><code data-noescape>
button.addActionListener(new ActionListener() {
    public void actionPerformed(ActionEvent event) {
        System.out.println("button clicked");
    }
});
                    </code></pre>
                    <!--<img width="300" height="200" src="imgs/54234567.jpg">-->
                    <aside class="notes">
                        existing code as data solution
                        <br /> aim: register a callback for when someone clicks a button
                        <br /> familiar with anonymous inner classes
                        <br /> bulky and verbose
                    </aside>
                </section>

                <section>
                    <h2>Code as Data</h2>
                    <pre><code data-noescape>
button.addActionListener(
    ?
);
                    </code></pre>
                    <aside class="notes">
                        outer method call is fine
                        <br /> issue is what goes in the middle, something that represents an action.
                    </aside>
                </section>

                <section>
                    <h2>Need a parameter</h2>
                    <pre><code data-noescape>
button.addActionListener(event

);
                    </code></pre>
                    <aside class="notes">
                        well we know the that we're passing in something
                        that gets given an event as a parameter
                    </aside>
                </section>

                <section>
                    <h2>Lambda Example</h2>
                    <pre><code data-noescape>
button.addActionListener(event ->
    System.out.println("button clicked")
);
                    </code></pre>
                    <aside class="notes">
                        <br /> previously required the type of the event
                        <br /> can be inferred from context
                        <br /> already in java 7: diamond operator
                    </aside>
                </section>

                <section>
                    <h2>No parameters</h2>
                    <pre><code data-noescape>
Runnable helloWorld =
    () -> System.out.println("Hello World");
                    </code></pre>
                    <aside class="notes">
                        also possible to infer the type from an assignment
                        <br /> no arguments variant of a lambda
                    </aside>
                </section>

                <section>
                    <h2>Variable Capture</h2>
                    <pre><code data-noescape>
String name = getUserName();
button.addActionListener(event ->
    System.out.println("hi " + name)
);
                    </code></pre>
                    <aside class="notes">
                        improvement over final variable
                        <br /> capturing non-final variables that are 'effectively final'.
                    </aside>
                </section>

                <section>
                    <h2>Functional Interfaces</h2>
                    <ul>
                        <li>Everything in Java has a type</li>
                        <li>Problem: Need types to represent Functions</li>
                        <li>Solution: Use interfaces</li>
                    </ul>
                    <aside class="notes">
                        6 is an int
                        <br /> new HashMap is a HashMap;
                    </aside>
                </section>

                <section>
                    <h2>Functional Interfaces</h2>
                    <pre><code data-noescape>
public interface ActionListener extends EventListener {
    public void actionPerformed(ActionEvent event);
}
                    </code></pre>
                    <aside class="notes">
                        here's the example method from earlier
                        <br > single abstract method
                    </aside>
                </section>

                <section>
                    <h2>Streams</h2>
                    <ul>
                        <li>Support automated data parallelism</li>
                        <li>Build computation pipelines</li>
                        <li>Iterator with inversion of control</li>
                    </ul>
                    <aside class="notes">
                        aim to seperate out the threading model
                        <br /> provide high level operations which are composable and reusable
                        <br /> not just beneficial for parallelism also makes code easier to read and reuse
                    </aside>
                </section>

                <section>
                    <h2>External Iteration</h2>
                    <pre><code data-noescape>
int count = 0;
for (Artist artist : artists) {
    if (artist.isFrom("London")) {
        count++;
    }
}
                    </code></pre>
                    <aside class="notes">
                        familiar concept
                        <br /> the control flow is driven by the code performing the operation
                        <br /> can't do parallel iteration
                    </aside>
                </section>

                <section>
                    <h2>Internal Iteration</h2>
                    <pre><code data-noescape>
artists.stream()
       .filter(artist -> artist.isFrom("London"))
       .count();
                    </code></pre>
                    <aside class="notes">
                        same code rewritten to use internal iteraion
                        <br /> there's no visible iteration!
                        <br /> iteration is delegated to the stream
                        <br /> this is why its an inversion of control: stream knows how to iterate effectively.
                        <br /> you may call into streams, but they call you back, which lets them control the threading model.
                    </aside>
                </section>

                <section>
                    <h2>map</h2>
                    <img src="imgs/map.png" />
                    <aside class="notes">
                        briefly talk about a few different types of stream operation
                        <br /> map: transform
                    </aside>
                </section>

                <section>
                    <h2>map</h2>
                    <pre><code data-noescape>
List&lt;String&gt; collected = Stream.of("a", "b", "hello")
                               .map(string -> string.toUpperCase())
                               .collect(toList());

assertEquals(asList("A", "B", "HELLO"), collected);
                    </code></pre>
                    <aside class="notes">
                        in code
                        <br /> Explain Stream.of
                        <br /> explain general form
                        <br /> point out the toUpperCase()
                    </aside>
                </section>

                <section>
                    <h2>reduce</h2>
                    <img src="imgs/reduce.png" />
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>reduce</h2>
                    <pre><code data-noescape>
int sum = Stream.of(1, 2, 3, 4)
                .reduce(0, (acc, x) -> acc + x);

assertEquals(10, sum);
                    </code></pre>
                    <aside class="notes">
                        remember to mention the sum()
                    </aside>
                </section>

                <section>
                    <h2>filter</h2>
                    <img src="imgs/filter.png" />
                    <aside class="notes">
                    </aside>
                </section>
                
                <section>
                    <h2>filter</h2>
                    <pre><code data-noescape>
List&lt;String&gt; beginningWithNumbers =   
    Stream.of("a", "1abc", "abc1")
          .filter(value -> isDigit(value.charAt(0)))
          .collect(toList());

assertEquals(asList("1abc"), beginningWithNumbers);
                    </code></pre>
                    <aside class="notes">
                        retain only strings whose first character is a digit.
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together</h2>
                    <p>for a given an album, find the nationality of every band playing on that album</p>
                    <aside class="notes">
                        go through a worked example of how to put together a pipeline
                        of stream operations.
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together (2)</h2>
                    <ol>
                        <li>transform an album into its artists</li>
                        <li>figure out which artists are bands</li>
                        <li>find the nationalities of each band</li>
                    </ol>
                    <aside class="notes">
                        give concrete example, eg 60s music compilation, beatles and monkeys
                    </aside>
                </section>

                <section>
                    <h2>Putting it all together (3)</h2>
                    <pre><code data-noescape>
List&lt;String&gt; origins =
  album.getMusicians()
       .filter(artist -> artist.getName().startsWith("The"))
       .map(artist -> artist.getNationality())
       .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        make joke about bands starting with the
                        <br />
                    </aside>
                </section>

                <section>
                    <h2>Method References</h2>
                    <pre><code data-noescape>
str -> str.length
String::length

x -> foo.bar(x)
foo::bar

str -> new Name(str)
Name::new
                    </code></pre>
                    <aside class="notes">
                        one more note about introductory stuff
                    </aside>
                </section>

                <section data-transition="linear" data-background="#8c4738" data-background-transition="slide">
                    <h1>Beyond the Myths</h1>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Claim: Syntax is the most important thing about Lambda Expressions</h2>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <blockquote>
                        Yeah, I liked the # syntax proposal better, too.  One less character
                        to type!  :)
                    </blockquote>
                    <aside class="notes">
                        Referring to a preference over ::
                    </aside>
				</section>

                <section>
                    <blockquote>
                        Have you considered 'default null'?  It will save a keyword
                    </blockquote>
                    <aside class="notes">
                        asking for things being too short at the expense of readability.
                    </aside>
				</section>

                <section>
                    <blockquote>
                        How about a single punctuation mark, currently unused, as syntax sugar
                        for "()->".
                    </blockquote>
                    <aside class="notes">
                        Extreme operator usage.
                    </aside>
				</section>

                <section>
                    <blockquote>
                        (_, _) -> _ + _
                    </blockquote>

                    <br />

                    <blockquote>
                        This is starting to look like risque ASCII art :)
                    </blockquote>
                    <aside class="notes">
                        Joke Slide: absurdism
                    </aside>
				</section>

                <section>
                    <h2>Its a Myth!</h2>
                    <img src="imgs/nessie.jpg" />
                    <aside class="notes">
                        People asked about the syntax but very little explanation and only a few examples were required.
                        <br /> Vast amounts more thought going into type inference, type system changes and overload resolution.
                    </aside>
                </section>

                <section>
                    <h2>Claim: Syntax is irrelevant</h2>
                    <img class="fragment" src="imgs/nessie-2.jpg" />
                    <aside class="notes">
                        Whilst token substitution not important, people did get tripped up on syntax.
                    </aside>
                </section>

                <section>
                    <pre><code data-trim>
// Originally invalid
Stream.of(1, 2, 3)
      .forEach(x -> System.out.println(x));

// Required extra ;
Stream.of(1, 2, 3)
      .forEach(x -> System.out.println(x););
                    </code></pre>
                    <aside class="notes">
                        Tripped up loads of people
                        <br />Incredibly confusing compiler message
                        <br />Issue was that println returned void and was a statement
                        <br />Need a ; at the end of statements
                        <br />thankfully fixed after being reported
                    </aside>
                </section>

                <section>
                    <h2>Difference between expectations</h2>
                    <ul>
                        <li>Many language features <strike>stolen!</strike> adapted</li>
                        <li>Missing Features
                        <ul>
                            <li>Stronger Type System</li>
                            <li>Tuples</li>
                            <li>List construction syntax</li>
                        </ul>
                    </ul>
                    <aside class="notes">
                        stolen vs adapted: frame of reference.  Reality is there's a lot of work to bring changes into Java 8.
                        <br /> Point is no Java dev I spoke to ever complained about the lack of higher kinded types.
                        <br /> experienced fpers from other areas wanted features they were used to.
                        <br /> Not a good or bad feature change, just a different perspective.
                    </aside>
                </section>

                <section>
                    <h2>Framing Effect</h2>
                    <p>Different reactions depending on whether something is presented as a loss or a gain.</p>
                    <aside class="notes">
                        Basic Psychology
                        <br /> "Prospect theory shows that a loss is more significant than the equivalent gain"
                        <br /> Coming from Scala: you might expect tuples and higher kinded types
                        <br /> Coming from Java 7 you're happy with what's provided
                        <br /> Also results in the general reaction from Scala devs that they aren't coming back
                    </aside>
                </section>

                <section>
                    <h2>Recall our earlier example</h2>
                    <pre><code data-noescape>
List&lt;String&gt; origins =
  album.getMusicians()
       .filter(artist -> artist.getName().startsWith("The"))
       .map(artist -> artist.getNationality())
       .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        Recall from earlier
                    </aside>
                </section>

                <section>
                    <h2>Eager vs Lazy (2)</h2>
                    <pre><code data-noescape>
  album.getMusicians()
       .filter(artist -> artist.getName().startsWith("The"))
       .map(artist -> artist.getNationality())

// What's happened?
       .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        does nothing
                        <br /> Streams are really builders for collections
                        <br /> people not at all understanding eager vs lazy was a common mistake
                        <br /> nothing is constructed untill the last call
                        <br /> just building up a recipe
                        <br /> key trick: anything that returns a Stream is lazy
                    </aside>
                </section>

<!--
                <section>
                    <h2>Eager vs Lazy (3)</h2>
                    <pre><code data-noescape>
  album.getMusicians()
       .filter(artist -> artist.getName().startsWith("The"))
       .map(artist -> artist.getNationality())
                    </code></pre>
                    <aside class="notes">
                        say 'last in the chain' is easger
                    </aside>
                </section>
-->

                <section>
                    <h2>Very little Testing</h2>
                    <p>Maybe ...</p>
                    <ul>
                        <li>a reflection on popularity of TDD</li>
                        <li>spikes are good for learning</li>
                        <li>unfamiliarity with testing lambdas</li>
                    </ul>
                    <aside class="notes">
                        might be part of a hackday environment: experimentation not reliable code
                        <br /> some people tried to do TDD
                        <br /> theoretically functional code easier to test
                        <br /> specification based testing
                    </aside>
                </section>

                <section>
                    <h2>How do I test this?</h2>
                    <pre><code data-noescape>
list.stream()
    .map(x -> 1.0 / Math.ceil(1 + Math.pow(x) + Math.atan2(y, x)))
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        Issue is that lambda expressions aren't reference-able.
                        <br /> Say your lambda expression interacts with a database: how do you mock it?
                        <br /> Anyone spot the subtle bug?
                        <br /> atan2(0,0) is mathematically undefined, Java gives an answer
                        <br /> NaN return, +ve/-ve 0, 10 infinity related special cases
                    </aside>
                </section>

                <section>
                    <h2>Approach 1: Test surrounding method</h2>
                    <ul>
                        <li>Don't test the lambda</li>
                        <li>Test the method its surrounded by</li>
                        <li>Works well for simple lambdas</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h2>Approach 2: Extract Method</h2>
                    <pre><code data-noescape>
double complexFunction(double x) {
    return 1.0 / Math.ceil(1 + Math.pow(x) + Math.atan2(0, x));
}

list.stream()
    .map(this::complexFunction)
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        extract your lambda out to a function if its complex.
                        <br /> Still get the code reuse and stream functionality through method references
                        <br /> remember to explain what a method reference is.
                        <br /> Method references really help testability for things like this.
                    </aside>
                </section>

                <section>
                    <h2>Mistake: debugging</h2>
                    <pre><code data-noescape>
// Streams
list.stream()
    .filter(filteringFunction)
    .map(mappingFunction)
    .collect(toList());

// Ye olde for loop
List&lt;Bar&gt; bars = new ArrayList&lt;&gt;();
for (Foo element : list) {
    if (filteringFunction(element) {
        Bar result = mappingFunction(element);
        bars.add(result);
    }
}
                    </code></pre>
                    <aside class="notes">
                        Issue is understanding intermediate values.
                    </aside>
                </section>

                <section>
                    <h2>peek</h2>
                    <pre><code data-noescape>
list.stream()
    .filter(filteringFunction)
    .peek(e -> System.out.println("Filtered value: " + e));
    .map(mappingFunction)
    .map(e -> e);
    .collect(toList());
                    </code></pre>
                    <aside class="notes">
                        could also be logging output or debugger breakpoint.
                        <br /> similar to the unix tee program.  Hands up.
                    </aside>
                </section>

                <!-- MAYBE: -->
                <!-- mention flatmap redesign? -->
                <!-- Pulling into local variables vs chaining -->

                <section>
                    <h2>Compiler Error Messages</h2>
                    <aside class="notes">
                        Very important
                        <br /> influential in the learning process.
                        <br /> Are they idiomatic? Are they easy to understand?
                    </aside>
                </section>

                <section>
                    <h2>Comparators</h2>
                    <pre><code data-noescape>
Comparator&lt;String&gt; comparator = comparing(String::length);

Comparator&lt;String&gt; comparator = comparing(str -> str.length);
                    </code></pre>
                    <aside class="notes">
                        Comparator is a functional interface.
                        <br /> provides some static methods for comparing by keys
                        <br /> explanatory example
                    </aside>
                </section>

                <section>
                    <h2>Compiler Error</h2>
                    <pre><code data-noescape>
java: reference to comparing is ambiguous both
method
&lt;T&gt;comparing(java.util.function.ToIntFunction&lt; ? super T&gt;)
in java.util.Comparator and method
&lt;T,U&gt;comparing(java.util.function.Function&lt; ? super T,? extends U&gt;)
in java.util.Comparator match
                    </code></pre>
                    <aside class="notes">
                        Overload resolution failure.
                        <br /> current state of play, but not likely to have a language fix
                        <br /> may change libraries
                    </aside>
                </section>

                <section>
                    <h2>What happened?</h2>
                    <pre><code data-noescape>
// Generic object variant
public static &lt;T, U extends Comparable&lt; ? super U&gt;&gt;
    Comparator&lt;T&gt;
        comparing(Function&lt; ? super T, ? extends U&gt; keyExtractor)

// Specialised primitive variant
public static &lt;T&gt;
    Comparator&lt;T&gt;
        comparing(ToIntFunction&lt; ? super T&gt; keyExtractor)
                    </code></pre>
                    <aside class="notes">
                        overloads are an issue
                        <br /> explain primitive specialised variant
                        <br /> overloads + type inference can be a bad combo, quite unusual
                        <br /> recommendation to library writers: don't overload on functional interfaces
                    </aside>
                </section>

                <section>
                    <h2>Summary</h2>
                    <ul>
                        <li>Syntax important, but not in the way people think</li>
                        <li>New approaches for debugging and testing</li>
                        <li>Take care of overloads and compiler error messages</li>
                    </ul>
                    <aside class="notes">
                    </aside>
                </section>

                <section data-transition="linear" data-background="#4d7e65" data-background-transition="slide">
                    <h1>Functional Thinking</h1>
                    <aside class="notes">
                        Say what I mean
                        <br /> look at a couple of examples
                        <br /> try and think of solutions
                    </aside>
                </section>

                <section>
                    <h1>Functional Thinking?</h1>
                    <p>Thinking in terms of the input to output relationship and not a sequence of steps</p>
                    <aside class="notes">
                        What is it?
                        <br /> Functional means different things to different communities
                        <br /> clojure: immutability, haskell: purity + monads, scala: a series of nouns which can be used for trolling.
                        <br /> Biggest issue that I saw: easy to develop and understand, but takes a bit of practise.
                        <br /> In the same way that patterns such as SOLID exist in OOP and take a while to develop.
                    </aside>
                </section>

                <section>
                    <h2>First code that people write</h2>
                    <pre><code data-noescape>
List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3);
numbers.forEach(x -> {
    System.out.println(x);
});
                    </pre></code>
                    <aside class="notes">
                        Pretty consistent in understanding internal vs external iteration.
                        <br /> not initially trying higher order functions.
                    </aside>
                </section>

                <section>
                    <h2>Non-idiomatic Proposals</h2>
                    <p>Eg: capture non-final local variables</p>
                    <aside class="notes">
                        A lot of people want features which aren’t in the direction of java 8
                        <br /> doesn't make parallelism easier.
                    </aside>
                </section>

                <section>
                    <h2>Example Problem</h2>
                    <p>Count the number of instances of each word in a document.</p>
                    <aside class="notes">
                        Example problem from the devoxx uk hackday
                        <br /> nominally simple problem
                        <br /> Required understanding of the collectors abstraction.
                        <br /> Given a reader as input.
                    </aside>
                </section>

                <section>
                    <h2>Ideal Solution</h2>
                    <pre><code data-noescape>
reader.lines()
      .flatMap(s -> s.splitAsStream(" "))
      .collect(groupingBy(s -> s, 
               counting()));
                    </pre></code>
                    <aside class="notes">
                        Explain code
                        <br /> explain the breakdown
                        <br /> emphasize the downstream collectors
                    </aside>
                </section>

                <section>
                    <h2>Ideal Solution (then)</h2>
                    <pre><code data-noescape>
reader.lines()
      .flatMap(s -> Stream.of(s.split(" ")))
      .collect(groupingBy(s -> s,
               reducing(s -> 1, Integer::sum)));

// Map entries for "dad"
// [ "dad", "dad", "dad" ] => [1, 1, 1] => 3
                    </pre></code>
                    <aside class="notes">
                        Counting not originally there.
                        <br /> Subsequently added.
                        <br /> People not only failed to get there, but also failed to understand the solution when presented
                    </aside>
                </section>

                <section>
                    <h2>Bad Solution (Part 1)</h2>
                    <pre><code data-noescape>
Map&lt;String, List&lt;String&gt;&gt; initial
      = br.lines()
          .flatMap(s -> Arrays.stream(s.split(" ")))
          .collect(groupingBy(s -> s));
  
  Map&lt;Map.Entry&lt;String, Integer&gt;, Integer&gt; freq1 = initial
    .entrySet().stream()
    .map(entry -> new AbstractMap.SimpleImmutableEntry&lt;String,
Integer&gt;(entry.getKey(), entry.getValue().size()))
    .collect(Collectors.toMap(entry -> entry.getValue()));
                    </pre></code>
                    <aside class="notes">
                        nearly right to begin with
                        <br />building the map up
                        <br />doesn't realise about downstream collectors
                    </aside>
                </section>

                <section>
                    <h2>Bad Solution (Part 2)</h2>
                    <pre><code>
  Supplier&lt;HashMap&lt;String, Integer&gt;&gt; supplier = () -&gt; new
HashMap&lt;String, Integer&gt;();
  BiConsumer&lt;HashMap&lt;String, Integer&gt;, Map.Entry&lt;String, Integer&gt;&gt; accum =
    (HashMap&lt;String, Integer&gt; result, Map.Entry&lt;String, Integer&gt;
entry) -> result.put(entry.getKey(), entry.getValue());
  BiConsumer&lt;HashMap&lt;String, Integer&gt;, HashMap&lt;String, Integer&gt;&gt;
merger = HashMap::putAll;

  Map&lt;String, Integer&gt; freq2 = initial.entrySet().stream()
    .map(entry -> new AbstractMap.SimpleImmutableEntry&lt;String,
Integer&gt;(entry.getKey(), entry.getValue().size()))
    .collect(supplier, accum, merger);
                    </pre></code>
                    <aside class="notes">
                        downhill from there, don't worry about understanding this code
                        <br /> make point of weird approach if things start looking like this
                        <br /> also, choose first steps wisely
                        <br /> sometimes indicates a lack of library knowledge
                        <br /> you'll write something like this, treat it as a learning experience not "FP is unreadable."
                    </aside>
                </section>

                <section>
                    <h2>This takes thought</h2>
                    <img src="imgs/stephen-colebourne.jpg" />
                    <aside class="notes">
                        <br /> emphasize he’s a really good programmer, conference speaker, jodatime author, JSR lead and EG member
                        <br /> mention annecdote with stuart marks' laptop
                    </aside>
                </section>

<!--
                <section>
                    <h2></h2>
                    <p></p>
                    <aside class="notes">
                    </aside>
                </section>

Maybe mention Continued Language weaknesses
immutable objects - findbugs/mutability detector
-->

<section>
                    <h2>Summary</h2>
                    <ul>
                        <li>Idioms are vital</li>
                        <li>Not Java specific at all</li>
                        <li>Requires Practise</li>
                    </ul>
                    <aside class="notes">
                        Recognising the problem is the first step
                    </aside>
                </section>

                <section>
                    <h1>Conclusions</h1>
                    <ul>
                        <li>Gone through a bunch of examples of specific issues</li>
                        <li>‘Functional Thinking’: Not necessary to start learning.</li>
                        <li>Try before you buy</li>
                    </ul>

                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h1>Q & A</h1>
                    <img src="imgs/rc_cat.gif" />
                    <p><a href="http://is.gd/lambdas">http://is.gd/lambdas</a></p>
                    <p>@RichardWarburto<p>
                    <p><a href="http://insightfullogic.com">http://insightfullogic.com</a></p>
                </section>

            </div>
        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.min.js"></script>

        <script>
            // Full list of configuration options available here:
            // https://github.com/hakimelreveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });
        </script>

</body>
</html>

